% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/oem.R
\name{oem}
\alias{oem}
\title{Orthogonalizing EM}
\usage{
oem(x, y, family = c("gaussian", "binomial"), penalty = c("elastic.net",
  "lasso", "ols", "mcp", "scad", "grp.lasso"), lambda = numeric(0),
  nlambda = 100L, lambda.min.ratio = NULL, alpha = 1, gamma = 3,
  groups = numeric(0), penalty.factor = NULL, group.weights = NULL,
  standardize = FALSE, intercept = TRUE, maxit = 500L, tol = 1e-07,
  irls.maxit = 100L, irls.tol = 0.001)
}
\arguments{
\item{x}{input matrix or SparseMatrix (sparse not yet implemented. 
Each row is an observation, each column corresponds to a covariate}

\item{y}{numeric response vector of length nobs.}

\item{family}{"gaussian" for least squares problems, "binomial" for binary response. "binomial" not yet implemented}

\item{penalty}{Specification of penalty type in lowercase letters. Choices include "lasso", 
"ols" (Ordinary least squares, no penaly), "elastic.net", "scad", "mcp"}

\item{lambda}{A user supplied lambda sequence. By default, the program computes
its own lambda sequence based on nlambda and lambda.min.ratio. Supplying
a value of lambda overrides this.}

\item{nlambda}{The number of lambda values - default is 100.}

\item{lambda.min.ratio}{Smallest value for lambda, as a fraction of lambda.max, the (data derived) entry
value (i.e. the smallest value for which all coefï¬cients are zero). The default
depends on the sample size nobs relative to the number of variables nvars. If
nobs > nvars, the default is 0.0001, close to zero. If nobs < nvars, the default
is 0.01. A very small value of lambda.min.ratio will lead to a saturated fit
when nobs < nvars.}

\item{alpha}{mixing value for elastic.net. penalty applied is (1 - alpha) * (ridge penalty) + alpha * (lasso penalty)}

\item{gamma}{tuning parameter for SCAD and MCP penalties}

\item{groups}{A vector of describing the grouping of the coefficients. See the example below.}

\item{penalty.factor}{Separate penalty factors can be applied to each coefficient. 
This is a number that multiplies lambda to allow differential shrinkage. Can be 0 for some variables, 
which implies no shrinkage, and that variable is always included in the model. Default is 1 for all 
variables.}

\item{group.weights}{penalty factors applied to each group for the group lasso. Similar to penalty.factor, 
this is a number that multiplies lambda to allow differential shrinkage. Can be 0 for some groups, 
which implies no shrinkage, and that group is always included in the model. Default is sqrt(group size) for all
groups.}

\item{maxit}{integer. Maximum number of OEM iterations}

\item{tol}{convergence tolerance for OEM iterations}

\item{irls.maxit}{integer. Maximum number of IRLS iterations}

\item{irls.tol}{convergence tolerance for IRLS iterations. Only used if family != "gaussian"}
}
\value{
An object with S3 class "oem.fit"
}
\description{
Orthogonalizing EM
}
\examples{
set.seed(123)
n.obs <- 1e4
n.vars <- 100

true.beta <- c(runif(15, -0.25, 0.25), rep(0, n.vars - 15))

x <- matrix(rnorm(n.obs * n.vars), n.obs, n.vars)
y <- rnorm(n.obs, sd = 3) + x \%*\% true.beta

fit <- oem(x = x, y = y, penalty = "lasso")

plot(fit)

fit.grp <- oem(x = x, y = y, penalty = "grp.lasso", groups = rep(1:20, each = 5))

plot(fit.grp)


# logistic
y <- rbinom(n.obs, 1, prob = 1 / (1 + exp(-x \%*\% true.beta)))

system.time(res <- oem(x, y, intercept = FALSE, penalty = "lasso", family = "binomial", irls.tol = 1e-3, tol = 1e-8))

library(glmnet)

system.time(glmn <- glmnet(x, y, lambda = res$lambda, standardize =FALSE, intercept = FALSE, family = "binomial", thresh = 1e-12))

max(abs(coef(glmn)[-1,] - res$beta[[1]][-1,]))

system.time(glmn <- glmnet(x, y, lambda = res$lambda, standardize =FALSE, intercept = FALSE, family = "binomial", thresh = 1e-15))

max(abs(coef(glmn)[-1,] - res$beta[[1]][-1,]))

system.time(glmn <- glmnet(x, y, lambda = res$lambda, standardize =FALSE, intercept = FALSE, family = "binomial", thresh = 1e-18))

## group lasso (logistic model)

library(gglasso)

system.time(res <- oem(x, y, intercept = FALSE, penalty = "grp.lasso", family = "binomial", irls.tol = 1e-3, tol = 1e-8, groups = rep(1:10, each = 10)))


system.time(ggl <- gglasso(x, 2 * y - 1, group = rep(1:10, each = 10), loss = "logit", lambda = res$lambda, intercept = FALSE, eps = 1e-8))
max(abs(ggl$beta - res$beta[[1]][-1,]))

system.time(ggl <- gglasso(x, 2 * y - 1, group = rep(1:10, each = 10), loss = "logit", lambda = res$lambda, intercept = FALSE, eps = 1e-10))
max(abs(ggl$beta - res$beta[[1]][-1,]))

system.time(ggl <- gglasso(x, 2 * y - 1, group = rep(1:10, each = 10), loss = "logit", lambda = res$lambda, intercept = FALSE, eps = 1e-12))
max(abs(ggl$beta - res$beta[[1]][-1,]))

}

